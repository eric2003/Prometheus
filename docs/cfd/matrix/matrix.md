# Matrix

## Numerical analysis

- [【台湾大学】数值分析 (2021 黄美娇)](https://www.bilibili.com/video/BV1BP411u7vK).
- [《数值分析》| 华科 | 研究生基础课](https://www.bilibili.com/video/BV1AK4y1k7Px).
- [数值分析 东南大学](https://www.bilibili.com/video/BV18A411E7ox/).
- [数值分析 中科大](https://www.bilibili.com/video/BV1T4411D7x5/).
- [计算方法（数值计算）-中国科学技术大学-傅孝明](https://www.bilibili.com/video/BV1WW4y1b7cT/).
- [数值分析 研究生基础课程-郑州大学](https://www.bilibili.com/video/BV19j421m7yF).
- [数值分析 东南大学](https://www.bilibili.com/video/BV18A411E7ox/).
- [大连理工大学 数值分析（自用）](https://www.bilibili.com/video/BV1cG4y1x7G1).

## 数值分析 (Numerical Analysis)

-  [数值分析 (Numerical Analysis)](https://math.ecnu.edu.cn/~jypan/Teaching/NA/2020/).
-  [【台湾大学】数值分析 (2021 黄美娇)](https://www.bilibili.com/video/BV1BP411u7vK/).
-  [【牛津大学】数值计算 Scientific Computing for DPhil Students 24讲 Nick Trefethen](https://www.bilibili.com/video/BV1VE411Q7ue/).
-  [Scientific Computing 科学计算/数值方法 牛津大学 中英字幕](https://www.bilibili.com/video/BV1sT4y1S7Aa/).
-  [英字【数值分析】斯坦福大学 CS 205A: Mathematical Methods for Robotics, Vision, and Graphics](https://www.bilibili.com/video/BV19J411t7Gh/).
-  [6.S955: Applied Numerical Algorithms](https://www.youtube.com/playlist?list=PLQ3UicqQtfNv_Io_NT1b0Nzr9YDqpK3Lb).

## Parallel Scientific Computing

-  [Parallel Scientific Computing](https://www.youtube.com/playlist?list=PL3xCBlatwrsUng53d3xBfzJdnltbO7god).
-  [Parallel Scientific Computing](https://www.youtube.com/playlist?list=PL3xCBlatwrsUng53d3xBfzJdnltbO7god).
-  [Parallel Numerical Algorithms](https://courses.grainger.illinois.edu/cs554/fa2015/syllabus/index.html).
-  [CS 554 | CSE 512 – Parallel Numerical Algorithms](https://courses.grainger.illinois.edu/cs554/fa2015/notes/index.html).
-  [Parallel algorithms. ITMO, 2022.](https://www.youtube.com/playlist?list=PLyQCF5K78w9-pEakBKyZDP-SJevWlXgik).
-  [An Efficient Parallel Solver for SDD Linear Systems](https://www.youtube.com/watch?v=X9bzQUxhZvM).
-  [Scientific Computing Lecture 13: Linear Algebra with BLAS and LAPACK](https://www.youtube.com/watch?v=jhxbk6AlCps).
-  [Rarray: Reference-Counted Multidimensional Arrays for C++](https://www.youtube.com/watch?v=gbMq6kkyb08).
-  [Scientific Computing - Lecture #1](https://www.youtube.com/watch?v=GZ6-10LJ2mM).
-  [Scientific Computing for Physicists 2017 Lecture2](https://www.youtube.com/watch?v=GZ6-10LJ2mM).

## Scientific Computing

-  [Scientific Computing - Lecture #1](https://www.youtube.com/watch?v=GZ6-10LJ2mM).
-  [Scientific Computing for Physicists 2017 Lecture2](https://www.youtube.com/watch?v=GZ6-10LJ2mM).
-  [Scientific Computing Lecture 3: Modular Programming](https://www.youtube.com/watch?v=E7K-wzCFEu0).
-  [Scientific Computing for Physicists 2017 Lecture 1](https://www.youtube.com/watch?v=uUpmvlvIOAI&list=PLZRRlbOTxTmCyLkmjWg0e8cNk6rONT-mk).
-  [Scientific Computing for Physicists 2017 Lecture 1](https://www.youtube.com/watch?v=uUpmvlvIOAI&list=PLZRRlbOTxTmCyLkmjWg0e8cNk6rONT-mk).

## Scientific Computing Playlist

-  [Scientific Computing (PHY1610, Winter 2017)](https://www.youtube.com/playlist?list=PLZRRlbOTxTmCyLkmjWg0e8cNk6rONT-mk).
-  [Beginning Scientific Computing](https://www.youtube.com/playlist?list=PLMrJAkhIeNNRTVrHYDfjNyqzZ6Q6rsTyf).
-  [Scientific Computing](https://www.youtube.com/playlist?list=PLA_-EWSPTJcvwNxwDpJyMnmdkIEWN_J6d).
-  [Scientific Computing using Python](https://www.youtube.com/playlist?list=PLFW6lRTa1g81Ig5maflwvtWCtyLf_MoTw).


## others

-  [Shape Analysis, spring 2023 (lecture 1): Introduction](https://www.youtube.com/watch?v=MS7kUDW9zPs&list=PLQ3UicqQtfNtHHgJRhkuBl3tzRdqeWUL9).
-  [Is the Future of Linear Algebra.. Random?](https://www.youtube.com/watch?v=6htbyY3rH1w).
-  [Parallel Algorithms (406CS)](https://www.youtube.com/playlist?list=PL8qSh0FX6KtUGCrH-Hhwx5KHUgmaCqx5B).


## Exascale Computing

-  [Exascale Computing](https://fiveable.me/exascale-computing).


## Tridiagonal matrix algorithm

- [Tridiagonal matrix algorithm](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm).

## Sherman–Morrison formula

- [Sherman-Morrison formula](https://en.wikipedia.org/wiki/Sherman-Morrison_formula).

## 三对角矩阵

- [三对角矩阵 时间点2:26:00 ](https://www.bilibili.com/video/BV1WW4y1b7cT/).

## Doolittle分解法

## PLU decomposition - An Example

- [PLU decomposition - An Example](https://www.youtube.com/watch?v=E3cCRcdFGmE).

* The stable parallel solution of general narrow banded linear systems

$$
  A=\begin{bmatrix}
  b_{1}&c_{1}  && && \\
  a_{2}&b_{2}&c_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1} \\
  &&  & &a_{n}&b_{n} \\
  \end{bmatrix}
$$

$$
  \begin{bmatrix}
  b_{1}&c_{1}  && && \\
  a_{2}&b_{2}&c_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1} \\
  &&  & &a_{n}&b_{n} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ \cdot \\\cdot \\x_{n-1}\\x_{n}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ \cdot \\\cdot \\y_{n-1}\\y_{n}
\end{bmatrix}
$$

$$
\left[\begin{array}{ccc|cc}
b_{1}&&&c_{1}&&\\
&b_{3}&&a_{3}&c_{3}&\\
&&\ddots&&\ddots&\ddots\\
\hline
a_{2}&c_{2}&&b_{2}\\
&a_{4}&\ddots&&b_{4}\\
&&\ddots&&&\ddots\\
\end{array}\right]
\left[\begin{array}{c}
 x_{1}\\x_{3}\\\vdots \\\hline x_{2}\\x_{4}\\\vdots
\end{array}
\right]
=\left[\begin{array}{c}
 y_{1}\\y_{3}\\\vdots \\\hline y_{2}\\y_{4}\\\vdots
\end{array}
\right]$$  

## Cyclic Reduction

For tridiagonal system, ith equation

$$
a_{i}x_{i-1}+b_{i}x_{i}+c_{i}x_{i+1}=y_{i}
$$

is transformed into

$$
\bar{a}_{i}x_{i-2}+\bar{b}_{i}x_{i}+\bar{c}_{i}x_{i+2}=\bar{y}_{i}
$$

where

$$
\begin{matrix}
  \bar{a}_{i}=\alpha_{i}{a}_{i-1},&\bar{b}_{i}={b}_{i}+\alpha_{i}{c}_{i-1}+\beta_{i}{a}_{i+1}\\
  \bar{c}_{i}=\beta_{i}{c}_{i+1},&\bar{y}_{i}={y}_{i}+\alpha_{i}{y}_{i-1}+\beta_{i}{y}_{i+1}\\
\end{matrix}
$$

with

$$
\begin{matrix}
 \alpha_{i}=-a_{i}/b_{i-1}\\
\beta_{i}=-c_{i}/b_{i+1}
\end{matrix}
$$

$$
\begin{bmatrix}
level&1&2&3\\
 1&1(1)&1(1)&1(1)\\
 2\\
 3&3(2)\\
 4\\
 5&5(3)&5(2)&5(1)\\
 6\\
 7&7(4)\\
 8
\end{bmatrix}
$$

$$
\begin{matrix}
a_{i-1}x_{i-2}&+&b_{i-1}x_{i-1}&+&c_{i-1}x_{i}&=&y_{i-1}\\
a_{i}x_{i-1}&+&b_{i}x_{i}&+&c_{i}x_{i+1}&=&y_{i}\\
a_{i+1}x_{i}&+&b_{i+1}x_{i+1}&+&c_{i+1}x_{i+2}&=&y_{i+1}\\
\end{matrix}
$$

$$
\begin{matrix}
\alpha a_{i-1}x_{i-2}&+&\alpha b_{i-1}x_{i-1}&+&\alpha c_{i-1}x_{i}&=&\alpha y_{i-1}\\
\beta a_{i}x_{i-1}&+&\beta b_{i}x_{i}&+&\beta c_{i}x_{i+1}&=&\beta y_{i}\\
\gamma a_{i+1}x_{i}&+&\gamma b_{i+1}x_{i+1}&+&\gamma c_{i+1}x_{i+2}&=&\gamma y_{i+1}\\
\end{matrix}
$$

$$
\begin{matrix}
&\alpha a_{i-1}x_{i-2}+\alpha b_{i-1}x_{i-1}+\beta a_{i}x_{i-1}+\alpha c_{i-1}x_{i}+\beta b_{i}x_{i}+\gamma a_{i+1}x_{i}\\
+&\beta c_{i}x_{i+1}+\gamma b_{i+1}x_{i+1}+\gamma c_{i+1}x_{i+2}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}\\
\end{matrix}
$$

$$
(\alpha b_{i-1}+\beta a_{i})x_{i-1}+(\beta c_{i}+\gamma b_{i+1})x_{i+1}
$$

Let

\begin{matrix}
\alpha b_{i-1}+\beta a_{i}=0\\
\beta c_{i}+\gamma b_{i+1}=0\\
\end{matrix}

Then

\begin{matrix}
\alpha c_{i}b_{i-1}-\gamma a_{i}b_{i+1}=0\\
\end{matrix}

$$
\begin{matrix}
(\alpha=\cfrac{a_{i}}{b_{i-1}} )c_{i}b_{i-1}-(\gamma=\cfrac{c_{i}}{b_{i+1}}) a_{i}b_{i+1}=0\\
\alpha=\cfrac{a_{i}}{b_{i-1}},\gamma=\cfrac{c_{i}}{b_{i+1}}
\end{matrix}
$$

$$
\begin{matrix}
\alpha=\cfrac{a_{i}}{b_{i-1}},\gamma=\cfrac{c_{i}}{b_{i+1}}\\
\alpha b_{i-1}+\beta a_{i}=0\\
\beta =-\alpha b_{i-1}/a_{i}=-1\\
\beta c_{i}+\gamma b_{i+1}=0\\
\beta =-\gamma b_{i+1}/c_{i}=-1\\
\end{matrix}
$$

Take the negative sign

$$
\begin{matrix}
\alpha=-\cfrac{a_{i}}{b_{i-1}}\\
\gamma=-\cfrac{c_{i}}{b_{i+1}}\\
\beta =1\\
\end{matrix}
$$

$$
\begin{array}{l}
\alpha a_{i-1}x_{i-2}+(\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1})x_{i}
+\gamma c_{i+1}x_{i+2}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}\\
\bar{a}_{i}=\alpha a_{i-1}\\
\bar{b}_{i}=\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1}\\
\bar{c}_{i}=\gamma c_{i+1}\\
\bar{y}_{i}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}
\end{array}
$$

$$
\begin{array}{l}
\alpha=-\cfrac{a_{i}}{b_{i-1}}\\
\gamma=-\cfrac{c_{i}}{b_{i+1}}\\
\beta =1\\
\bar{a}_{i}=\alpha a_{i-1}\\
\bar{b}_{i}=\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1}\\
\bar{c}_{i}=\gamma c_{i+1}\\
\bar{y}_{i}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}
\end{array}
$$

$$
\begin{array}{l}
\alpha=-\cfrac{a_{i}}{b_{i-1}}\\
\gamma=-\cfrac{c_{i}}{b_{i+1}}\\
\bar{a}_{i}=\alpha a_{i-1}\\
\bar{b}_{i}=\alpha c_{i-1}+b_{i}+\gamma a_{i+1}\\
\bar{c}_{i}=\gamma c_{i+1}\\
\bar{y}_{i}=\alpha y_{i-1}+y_{i}+\gamma y_{i+1}
\end{array}
$$

$$
\begin{array}{l}
\alpha=-\cfrac{a_{i}}{b_{i-1}}\\
\gamma=-\cfrac{c_{i}}{b_{i+1}}\\
\bar{a}_{i}=-\cfrac{a_{i}}{b_{i-1}}a_{i-1}\\
\bar{b}_{i}=-\cfrac{a_{i}}{b_{i-1}}c_{i-1}+b_{i}-\cfrac{c_{i}}{b_{i+1}}a_{i+1}\\
\bar{c}_{i}=-\cfrac{c_{i}}{b_{i+1}}c_{i+1}\\
\bar{y}_{i}=-\cfrac{a_{i}}{b_{i-1}}y_{i-1}+y_{i}-\cfrac{c_{i}}{b_{i+1}}y_{i+1}
\end{array}
$$

$$
\begin{array}{l}
\bar{a}_{i}=-a_{i}\cfrac{a_{i-1}}{b_{i-1}}\\
\bar{b}_{i}=-a_{i}\cfrac{c_{i-1}}{b_{i-1}}+b_{i}-c_{i}\cfrac{a_{i+1}}{b_{i+1}}\\
\bar{c}_{i}=-c_{i}\cfrac{c_{i+1}}{b_{i+1}}\\
\bar{y}_{i}=-a_{i}\cfrac{y_{i-1}}{b_{i-1}}+y_{i}-c_{i}\cfrac{y_{i+1}}{b_{i+1}}
\end{array}
$$

$$
\begin{array}{l}
\tilde{a}_i=\cfrac{\bar{a}_{i}}{b_{i}}=-\cfrac{a_{i}}{b_{i}}\cfrac{a_{i-1}}{b_{i-1}}\\
\tilde{b}_i=\cfrac{\bar{b}_{i}}{b_{i}}=-\cfrac{a_{i}}{b_{i}}\cfrac{c_{i-1}}{b_{i-1}}+\cfrac{b_{i}}{b_{i}}-\cfrac{c_{i}}{b_{i}}\cfrac{a_{i+1}}{b_{i+1}}\\
\tilde{c}_i=\cfrac{\bar{c}_{i}}{b_{i}}=-\cfrac{c_{i}}{b_{i}}\cfrac{c_{i+1}}{b_{i+1}}\\
\tilde{y}_i=\cfrac{\bar{y}_{i}}{b_{i}}=-\cfrac{a_{i}}{b_{i}}\cfrac{y_{i-1}}{b_{i-1}}+\cfrac{y_{i}}{b_{i}}-\cfrac{c_{i}}{b_{i}}\cfrac{y_{i+1}}{b_{i+1}}
\end{array}
$$

* Normalize a,b,c,d

```cpp
for( int i = 1; i <= N; ++ i )
{
    aa[i] = a[i]/b[i];
	cc[i] = c[i]/b[i];
	yy[i] = y[i]/b[i];
	bb[i] = b[i]/b[i];
}

for( int i = 1; i <= N; ++ i )
{
    a_bar[i] = -aa[i]*aa[i-1];
	c_bar[i] = -cc[i]*cc[i+1];
	y_bar[i] = -aa[i]*yy[i-1] + yy[i] - cc[i]*yy[i+1];
	b_bar[i] = -aa[i]*cc[i-1] + bb[i] - cc[i]*aa[i+1];
}
```

ALOGRITHM 2: PCR Algorithms

```cpp
level    1    2    3
  1    1(1)  1(1) 1(1)
  2
  3    3(2)
  4
  5    5(3)  5(2) 5(1)
  6
  7    7(4)
  8
```

getabcy
```cpp
1. getabcy N=8
2. ag[1],ag[3],ag[5],ag[7] N = 4, step = 2
   a[1,2,3,4]: ag[1,3,5,7]
for( int i = 1; i <= 4; ++ i )
{
    int ig = 2*i - 1;//(1,3,5,7) step=2
    aa[i] = a[i]/b[i] = ag[ig]/bg[ig] = aag[ig];
	cc[i] = c[i]/b[i] = cg[ig]/bg[ig] = ccg[ig];
	yy[i] = y[i]/b[i] = yg[ig]/bg[ig] = yyg[ig];
	bb[i] = b[i]/b[i] = bg[ig]/bg[ig] = bbg[ig];
}

for( int i = 1; i <= N; ++ i )
{
    int ig = 2*(i-1) + 1;//(1,3,5,7) step=2
	int ign1 = ig - 2 = ig - step;
	int igp1 = ig + 2 = ig + step;
    a_bar[i] = -aa[i]*aa[i-1] = -aag[ig]*aag[ign1] = a_barg[ig];
	c_bar[i] = -cc[i]*cc[i+1] = -ccg[ig]*ccg[igp1] = c_barg[ig];
	y_bar[i] = -aa[i]*yy[i-1] + yy[i] - cc[i]*yy[i+1];
	b_bar[i] = -aa[i]*cc[i-1] + bb[i] - cc[i]*aa[i+1];
	y_barg[ig] = -aag[ig]*yyg[ign1] + yyg[ig] - ccg[ig]*yyg[igp1];	
	b_barg[ig] = -aag[ig]*ccg[ign1] + bbg[ig] - ccg[ig]*aag[igp1];
}

3. ag[1],ag[5] N = 2, step = 4
   a[1,2]: ag[1,5]
for( int i = 1; i <= 2; ++ i )
{
    int ig = 4*(i-1) + 1;//(1,5) step = 4
    aa[i] = a[i]/b[i] = ag[ig] / bg[ig];
	cc[i] = c[i]/b[i] = cg[ig] / bg[ig];
	yy[i] = y[i]/b[i] = yg[ig] / bg[ig];
	bb[i] = b[i]/b[i] = bg[ig] / bg[ig];
}

for( int i = 1; i <= N; ++ i ) //N=2
{
    int ig = 4*(i-1) + 1;//(1,5) step=4
	int ign1 = ig - 4 = ig - step;
	int igp1 = ig + 4 = ig + step;
    a_bar[i] = -aa[i]*aa[i-1] = -aag[ig]*aag[ign1] = a_barg[ig];
	c_bar[i] = -cc[i]*cc[i+1] = -ccg[ig]*ccg[igp1] = c_barg[ig];
	y_bar[i] = -aa[i]*yy[i-1] + yy[i] - cc[i]*yy[i+1];
	b_bar[i] = -aa[i]*cc[i-1] + bb[i] - cc[i]*aa[i+1];
	y_barg[ig] = -aag[ig]*yyg[ign1] + yyg[ig] - ccg[ig]*yyg[igp1];	
	b_barg[ig] = -aag[ig]*ccg[ign1] + bbg[ig] - ccg[ig]*aag[igp1];
}


```

```cpp
int nLevel = log2(N+1) -1;
int joffset;
for( int p = 1; p <= nLevel; ++ p )
{
    int s = 2^p-1;
	joffset
	for( int j = start; j <; j += joffset )
	{
        ip = i - dist_row;
        in = min(i + dist_row, n_mpi + 1);
	}
}
```


$$
\begin{bmatrix}
  b_{1}&c_{1}  && && \\
  a_{2}&b_{2}&c_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1} \\
  &&  & &a_{n}&b_{n} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ \cdot \\\cdot \\x_{n-1}\\x_{n}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ \cdot \\\cdot \\y_{n-1}\\y_{n}
\end{bmatrix}
$$

$$
\begin{bmatrix}
  1&c_{1}/b_{1}  && && \\
  a_{2}/b_{2}&1&c_{2}/b_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1}/b_{n-1} \\
  &&  & &a_{n}/b_{n}&1 \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ \cdot \\\cdot \\x_{n-1}\\x_{n}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}/b_{1}\\ y_{2}/b_{2}\\ \cdot \\\cdot \\y_{n-1}/b_{n-1}\\y_{n}/b_{n}
\end{bmatrix}
$$

在不妨碍理解的情况下，记

$$
\begin{bmatrix}
  1&c_{1}  && && \\
  a_{2}&1&c_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1} \\
  &&  & &a_{n}&1 \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ \cdot \\\cdot \\x_{n-1}\\x_{n}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ \cdot \\\cdot \\y_{n-1}\\y_{n}
\end{bmatrix}
$$

For tridiagonal system, ith equation

$$
a_{i}x_{i-1}+x_{i}+c_{i}x_{i+1}=y_{i}
$$

$$
\begin{matrix}
a_{i-1}x_{i-2}&+&x_{i-1}&+&c_{i-1}x_{i}&=&y_{i-1}\\
a_{i}x_{i-1}&+&x_{i}&+&c_{i}x_{i+1}&=&y_{i}\\
a_{i+1}x_{i}&+&x_{i+1}&+&c_{i+1}x_{i+2}&=&y_{i+1}\\
\end{matrix}
$$

$$
\begin{matrix}
\alpha a_{i-1}x_{i-2}&+&\alpha{x}_{i-1}&+&\alpha c_{i-1}x_{i}&=&\alpha y_{i-1}\\
\beta a_{i}x_{i-1}&+&\beta{x}_{i}&+&\beta c_{i}x_{i+1}&=&\beta y_{i}\\
\gamma a_{i+1}x_{i}&+&\gamma{x}_{i+1}&+&\gamma c_{i+1}x_{i+2}&=&\gamma y_{i+1}\\
\end{matrix}
$$

$$
\begin{matrix}
&\alpha a_{i-1}x_{i-2}+\alpha{x}_{i-1}+\beta a_{i}x_{i-1}+\alpha{c}_{i-1}x_{i}+\beta{x}_{i}+\gamma{a}_{i+1}x_{i}\\
+&\beta{c}_{i}x_{i+1}+\gamma{x}_{i+1}+\gamma c_{i+1}x_{i+2}=\alpha y_{i-1}+\beta y_{i}+\gamma{y}_{i+1}\\
\end{matrix}
$$

$$
\begin{array}{c}
\alpha{x}_{i-1}+\beta a_{i}x_{i-1}=0\Rightarrow \alpha+\beta a_{i}=0\\
\beta{c}_{i}x_{i+1}+\gamma{x}_{i+1}=0\Rightarrow \beta{c}_{i}+\gamma=0\\
\end{array}
$$

$$
\begin{array}{c}
\beta =1\\
\alpha=-a_{i}\\
\gamma=-{c}_{i}\\
\end{array}
$$

$$
\begin{array}{l}
\alpha a_{i-1}x_{i-2}+(\alpha{c}_{i-1}+1+\gamma{a}_{i+1})x_{i}+
\gamma c_{i+1}x_{i+2}=\alpha y_{i-1}+y_{i}+\gamma{y}_{i+1}\\
\bar{a}_{i}x_{i-2}+\bar{b}_{i}x_{i}+\bar{c}_{i}x_{i+2}=\bar{y}_i\\
\bar{a}_{i}=\alpha{a}_{i-1}=-{a}_{i}{a}_{i-1}\\
\bar{c}_{i}=\gamma{c}_{i+1}=-{c}_{i}{c}_{i+1}\\
\bar{b}_{i}=\alpha{c}_{i-1}+1+\gamma{a}_{i+1}=-a_{i}{c}_{i-1}+1-c_{i}c_{i+1}\\
\bar{y}_i=\alpha y_{i-1}+y_{i}+\gamma{y}_{i+1}=-a_{i}{y}_{i-1}+y_{i}-c_{i}y_{i+1}\\
\end{array}
$$


Matrix Iterative Analysis

To better explain the code, we have broken the entire program into multiple parts. The
serial code is broken down into three parts as follows:

1. Part 1 - Memory allocation and generation of the matrix A.
2. Part 2 - Cyclic reduction stages.
3. Part 3 - Cyclic reduction back substitution to recover the solution.

For each part, we will first present the code and then present a collection of remarks elucidating the salient points within each part.

Serial
```cpp
    //Cyclic reduction
    for ( int i = 0; i < std::log2( size + 1 ) - 1; ++ i )
    {
        std::print( "i={}\n", i );
        for ( int j = std::pow( 2, i + 1 ) - 1; j < size; j = j + std::pow( 2, i + 1 ) )
        {
            int offset = std::pow( 2, i );
            int index1 = j - offset;
            int index2 = j + offset;
            double alpha = A[ j ][ index1 ] / A[ index1 ][ index1 ];
            double gamma = A[ j ][ index2 ] / A[ index2 ][ index2 ];
            std::print( "index1,j,index2 = ({},{},{})\n", index1, j, index2 );
            for ( int k = 0; k < size; ++ k )
            {
                A[ j ][ k ] -= ( alpha * A[ index1 ][ k ] + gamma * A[ index2 ][ k ] );
                std::print( "({},{})", j, k );
            }
            std::println();
            F[ j ] -= ( alpha * F[ index1 ] + gamma * F[ index2 ] );
        }
    }
```

output
```powershell
i=0
index1,j,index2 = (0,1,2)
(1,0)(1,1)(1,2)(1,3)(1,4)(1,5)(1,6)(1,7)(1,8)(1,9)(1,10)(1,11)(1,12)(1,13)(1,14)
index1,j,index2 = (2,3,4)
(3,0)(3,1)(3,2)(3,3)(3,4)(3,5)(3,6)(3,7)(3,8)(3,9)(3,10)(3,11)(3,12)(3,13)(3,14)
index1,j,index2 = (4,5,6)
(5,0)(5,1)(5,2)(5,3)(5,4)(5,5)(5,6)(5,7)(5,8)(5,9)(5,10)(5,11)(5,12)(5,13)(5,14)
index1,j,index2 = (6,7,8)
(7,0)(7,1)(7,2)(7,3)(7,4)(7,5)(7,6)(7,7)(7,8)(7,9)(7,10)(7,11)(7,12)(7,13)(7,14)
index1,j,index2 = (8,9,10)
(9,0)(9,1)(9,2)(9,3)(9,4)(9,5)(9,6)(9,7)(9,8)(9,9)(9,10)(9,11)(9,12)(9,13)(9,14)
index1,j,index2 = (10,11,12)
(11,0)(11,1)(11,2)(11,3)(11,4)(11,5)(11,6)(11,7)(11,8)(11,9)(11,10)(11,11)(11,12)(11,13)(11,14)
index1,j,index2 = (12,13,14)
(13,0)(13,1)(13,2)(13,3)(13,4)(13,5)(13,6)(13,7)(13,8)(13,9)(13,10)(13,11)(13,12)(13,13)(13,14)
i=1
index1,j,index2 = (1,3,5)
(3,0)(3,1)(3,2)(3,3)(3,4)(3,5)(3,6)(3,7)(3,8)(3,9)(3,10)(3,11)(3,12)(3,13)(3,14)
index1,j,index2 = (5,7,9)
(7,0)(7,1)(7,2)(7,3)(7,4)(7,5)(7,6)(7,7)(7,8)(7,9)(7,10)(7,11)(7,12)(7,13)(7,14)
index1,j,index2 = (9,11,13)
(11,0)(11,1)(11,2)(11,3)(11,4)(11,5)(11,6)(11,7)(11,8)(11,9)(11,10)(11,11)(11,12)(11,13)(11,14)
i=2
index1,j,index2 = (3,7,11)
(7,0)(7,1)(7,2)(7,3)(7,4)(7,5)(7,6)(7,7)(7,8)(7,9)(7,10)(7,11)(7,12)(7,13)(7,14)
```

```
Back substitution i=2
index1,j,index2 = (3,7,11)
x[3] = -136, x[11]=-200
Back substitution i=1
index1,j,index2 = (1,3,5)
x[1] = -70, x[5]=-190
index1,j,index2 = (5,7,9)
x[5] = -190, x[9]=-230
index1,j,index2 = (9,11,13)
x[9] = -230, x[13]=-126
Back substitution i=0
index1,j,index2 = (0,1,2)
x[0] = -35, x[2]=-104
index1,j,index2 = (2,3,4)
x[2] = -104, x[4]=-165
index1,j,index2 = (4,5,6)
x[4] = -165, x[6]=-210
index1,j,index2 = (6,7,8)
x[6] = -210, x[8]=-231
index1,j,index2 = (8,9,10)
x[8] = -231, x[10]=-220
index1,j,index2 = (10,11,12)
x[10] = -220, x[12]=-169
index1,j,index2 = (12,13,14)
x[12] = -169, x[14]=-70
-35
-70
-104
-136
-165
-190
-210
-224
-231
-230
-220
-200
-169
-126
-70
```

```
7,3,11,1,5,5,9,9,13,0,2,4,6,6,8,,8,10,10,12,12,14
```

```cpp
import std;

void Print( std::vector<double> & x, const std::string & name = "vector" )
{
    std::print( "{} = ", name );
    for ( auto v: x )
    {
        std::print( "{} ", v );
    }
    std::println();
}

void Print( std::vector<std::vector<double>> & a, const std::string & name = "matrix" )
{
    int N = a.size();
    for ( int i = 0; i < N; ++ i )
    {
        for ( int j = 0; j < N; ++ j )
        {
            std::print( "{:10f} ", a[ i ][ j ] );
        }
        std::println();
    }
    std::println();
}

void MatrixMultiply( std::vector<std::vector<double>> & a, std::vector<double> & x, std::vector<double> & y )
{
    int N = a.size();
    for ( int i = 0; i < N; ++ i )
    {
        y[ i ] = 0.0;
        for ( int j = 0; j < N; ++ j )
        {
            y[ i ] += a[ i ][ j ] * x[ j ];
        }
    }
}


int main( int argc, char ** argv )
{
    //Memory allocation and generation of matrix
    //const int size = 15;
    const int size = 3;
    std::vector<double> x( size );
    for ( int i = 0; i < size; ++ i )
    {
        x[ i ] = 0.0;
    }
    std::vector<double> F( size );
    std::vector<std::vector<double>> A( size );
    for ( int i = 0; i < size; ++ i )
    {
        A[ i ].resize( size );
        for ( int j = 0; j < size; ++ j )
        {
            A[ i ][ j ] = 0.0;
        }
        F[ i ] = i;
    }
    A[ 0 ][ 0 ] = -2.0;
    A[ 0 ][ 1 ] = 1.0;
    A[ size - 1 ][ size - 2 ] = 1.0;
    A[ size - 1 ][ size - 1 ] = -2.0;
    for ( int i = 1; i < size - 1; ++ i )
    {
        A[ i ][ i ] = -2.0;
        A[ i ][ i - 1 ] = 1.0;
        A[ i ][ i + 1 ] = 1.0;
    }

    Print( A, "matrix A" );

    std::vector<std::vector<double>> AA = A;
    std::vector<double> FF = F;

    //Cyclic reduction
    for ( int i = 0; i < std::log2( size + 1 ) - 1; ++ i )
    {
        std::print( "Cyclic reduction i = {}\n", i );
        for ( int j = std::pow( 2, i + 1 ) - 1; j < size; j = j + std::pow( 2, i + 1 ) )
        {
            int offset = std::pow( 2, i );
            int index1 = j - offset;
            int index2 = j + offset;
            double alpha = A[ j ][ index1 ] / A[ index1 ][ index1 ];
            double gamma = A[ j ][ index2 ] / A[ index2 ][ index2 ];
            std::print( "index1,j,index2 = ({},{},{})\n", index1, j, index2 );
            for ( int k = 0; k < size; ++ k )
            {
                A[ j ][ k ] -= ( alpha * A[ index1 ][ k ] + gamma * A[ index2 ][ k ] );
                std::print( "({},{})", j, k );
            }
            std::println();
            F[ j ] -= ( alpha * F[ index1 ] + gamma * F[ index2 ] );
        }
    }
    //Back substitution
    int index = ( size - 1 ) / 2;
    x[ index ] = F[ index ] / A[ index ][ index ];
    std::print( "F[{}] = {}, A[{}][{}]={}\n", index, F[ index ], index, index, A[ index ][ index ] );
    std::print( "x[{}] = {}\n", index, x[ index ] );
    for ( int i = std::log2( size + 1 ) - 2; i >= 0; -- i )
    {
        std::print( "Back substitution i = {}\n", i );
        for ( int j = std::pow( 2, i + 1 ) - 1; j < size; j = j + std::pow( 2, i + 1 ) )
        {
            int offset = std::pow( 2, i );
            int index1 = j - offset;
            int index2 = j + offset;
            std::print( "index1,j,index2 = ({},{},{})\n", index1, j, index2 );
            x[ index1 ] = F[ index1 ];
            x[ index2 ] = F[ index2 ];
            for ( int k = 0; k < size; ++ k )
            {
                if ( k != index1 )
                {
                    x[ index1 ] -= A[ index1 ][ k ] * x[ k ];
                }
                if ( k != index2 )
                {
                    x[ index2 ] -= A[ index2 ][ k ] * x[ k ];
                }
            }
            x[ index1 ] = x[ index1 ] / A[ index1 ][ index1 ];
            x[ index2 ] = x[ index2 ] / A[ index2 ][ index2 ];
            std::print( "x[{}] = {}, x[{}] = {}\n", index1, x[ index1 ], index2, x[ index2 ] );
        }
    }

    for ( int i = 0; i < size; ++ i )
    {
        std::println( "{}", x[i] );
    }

    std::vector<double> y( F.size() );
    MatrixMultiply( AA, x, y );
    Print( y, "y" );
    Print( FF, "FF" );

    return 0;
}
```

output
```powershell
 -2.000000   1.000000   0.000000
  1.000000  -2.000000   1.000000
  0.000000   1.000000  -2.000000

Cyclic reduction i = 0
index1,j,index2 = (0,1,2)
(1,0)(1,1)(1,2)
F[1] = 2, A[1][1]=-1
x[1] = -2
Back substitution i = 0
index1,j,index2 = (0,1,2)
x[0] = -1, x[2] = -2
-1
-2
-2
y = 0 1 2
FF = 0 1 2
```

output
```powershell
-2.000000   1.000000   0.000000
  1.000000  -2.000000   1.000000
  0.000000   1.000000  -2.000000

vector F = 0 1 2
Cyclic reduction i = 0
index1,j,index2 = (0,1,2)
A[1][0]=1
A[1][2]=1
A[0][0]=-2
A[2][2]=-2
alpha = -0.5, gamma = -0.5
j,k=(1,0) index1,k=(0,0) index2,k=(2,0)
j,k=(1,1) index1,k=(0,1) index2,k=(2,1)
j,k=(1,2) index1,k=(0,2) index2,k=(2,2)

 -2.000000   1.000000   0.000000
  0.000000  -1.000000   0.000000
  0.000000   1.000000  -2.000000

vector F after cyclic reduction = 0 2 2
F[1] = 2, A[1][1]=-1
x[1] = -2
Back substitution i = 0
index1,j,index2 = (0,1,2)
x[0] = -1, x[2] = -2
-1
-2
-2
y = 0 1 2
FF = 0 1 2
```

$$
  \begin{bmatrix}
  b_{1}&c_{1}  && && \\
  a_{2}&b_{2}&c_{2} & & & \\
  &.&.  &. & \\
  &&.  &. &.& \\
  &&  &. &.&c_{n-1} \\
  &&  & &a_{n}&b_{n} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ \cdot \\\cdot \\x_{n-1}\\x_{n}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ \cdot \\\cdot \\y_{n-1}\\y_{n}
\end{bmatrix}
$$

$$
\begin{array}{l}
\alpha a_{i-1}x_{i-2}+(\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1})x_{i}
+\gamma c_{i+1}x_{i+2}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}\\
\bar{a}_{i}=\alpha a_{i-1}\\
\bar{b}_{i}=\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1}\\
\bar{c}_{i}=\gamma c_{i+1}\\
\bar{y}_{i}=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}
\end{array}
$$

step1

$$
\begin{bmatrix}
  b_{1}&c_{1}  && &&& \\
  a_{2}&b_{2}&c_{2} && & & \\
  &a_{3}&b_{3}&c_{3}&& \\
  &&a_{4}&b_{4}&c_{4}&& \\
  &&  &a_{5}&b_{5}&c_{5}& \\
  &&  & &a_{6}&b_{6}&c_{6} \\
&&  & &&a_{7}&b_{7} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3} \\x_{4} \\x_{5}\\x_{6}\\x_{7}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ y_{3} \\y_{4} \\y_{5}\\y_{6}\\y_{7}
\end{bmatrix}
$$

step2

$$
  \begin{bmatrix}
  b_{1}&c_{1}  && &&& \\
  &\hat{b}_{2}& &\hat{c}_{2}& & & \\
  &a_{3}&b_{3}&c_{3}&& \\
  &\hat{a}_{4}&&\hat{b}_{4}&&\hat{c}_{4}& \\
  &&  &a_{5}&b_{5}&c_{5}& \\
  &&  &\hat{a}_{6} &&\hat{b}_{6}& \\
&&  & &&a_{7}&b_{7} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3} \\x_{4} \\x_{5}\\x_{6}\\x_{7}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ \hat{y}_{2}\\ y_{3} \\\hat{y}_{4} \\y_{5}\\\hat{y}_{6}\\y_{7}
\end{bmatrix}
$$

step3

$$
  \begin{bmatrix}
  b_{1}&c_{1}  && &&& \\
  &\hat{b}_{2}& &\hat{c}_{2}& & & \\
  &a_{3}&b_{3}&c_{3}&& \\
  &&&{b}^{*}_{4}&&& \\
  &&  &a_{5}&b_{5}&c_{5}& \\
  &&  &\hat{a}_{6} &&\hat{b}_{6}& \\
&&  & &&a_{7}&b_{7} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3} \\x_{4} \\x_{5}\\x_{6}\\x_{7}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ \hat{y}_{2}\\ y_{3} \\{y}^{*}_{4} \\y_{5}\\\hat{y}_{6}\\y_{7}
\end{bmatrix}
$$

```
F[3] = 12, A[3][3]=-0.5
x[3] = -24
Back substitution level = 1
in,j,ip = (1,3,5)
x[1] = -14, x[5] = -22
Back substitution level = 0
in,j,ip = (0,1,2)
x[0] = -7, x[2] = -20
in,j,ip = (2,3,4)
x[2] = -20, x[4] = -25
in,j,ip = (4,5,6)
x[4] = -25, x[6] = -14
```

```
3 1 5 0 2 2 4 4 6
4 2 6 1 3 3 5 5 7


```

## 3 equation

$$
\begin{bmatrix}
  b_{1}&c_{1}   \\
  a_{2}&b_{2}&c_{2} \\
  &a_{3}&b_{3} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ y_{3}
\end{bmatrix}
$$

$$
\begin{array}{l}
b_{1}x_{1}&+&c_{1}x_{2}&&&=&y_{1}\\
a_{2}x_{1}&+&b_{2}x_{2}&+&c_{2}x_{3}&=&y_{2}\\
&&a_{3}x_{2}&+&b_{3}x_{3}&=&y_{3}\\
\end{array}
$$

$$
\begin{array}{l}
\alpha_{2}b_{1}x_{1}&+&\alpha_{2}c_{1}x_{2}&&&=&\alpha_{2}y_{1}\\
\beta_{2}a_{2}x_{1}&+&\beta_{2}b_{2}x_{2}&+&\beta_{2}c_{2}x_{3}&=&\beta_{2}y_{2}\\
&&\gamma_{2}a_{3}x_{2}&+&\gamma_{2}b_{3}x_{3}&=&\gamma_{2}y_{3}\\
\end{array}
$$

$$
(\alpha_{2}b_{1}+\beta_{2}a_{2})x_{1}+
(\alpha_{2}c_{1}+\beta_{2}b_{2}+\gamma_{2}a_{3})x_{2}+
(\beta_{2}c_{2}+\gamma_{2}b_{3})x_{3}=
\alpha_{2}y_{1}+\beta_{2}y_{2}+\gamma_{2}y_{3}
$$

$$
\begin{array}{l}
\alpha_{2}b_{1}+\beta_{2}a_{2}=0\\
\beta_{2}c_{2}+\gamma_{2}b_{3}=0\\
\beta_{2}=1\\
\end{array}
$$

$$
\begin{array}{l}
\alpha_{2}b_{1}+a_{2}=0\Rightarrow \alpha_{2}=-a_{2}/b_{1}\\
c_{2}+\gamma_{2}b_{3}=0\Rightarrow \gamma_{2}=-c_{2}/b_{3}\\
\beta_{2}=1\\
\end{array}
$$

$$
\begin{array}{l}
\hat{b}_{2}=\alpha_{2}c_{1}+\beta_{2}b_{2}+\gamma_{2}a_{3}\\
\hat{y}_{2}=\alpha_{2}y_{1}+\beta_{2}y_{2}+\gamma_{2}y_{3}\\
\hat{b}_{2}=\alpha_{2}c_{1}+b_{2}+\gamma_{2}a_{3}\\
\hat{y}_{2}=\alpha_{2}y_{1}+y_{2}+\gamma_{2}y_{3}\\
\end{array}
$$

$$
\begin{array}{l}
\hat{b}_{2}{x}_{2}=\hat{y}_{2}\\
{x}_{2}=\hat{y}_{2}/\hat{b}_{2}\\
\end{array}
$$

$$
\begin{array}{l}
b_{1}x_{1}&+&c_{1}x_{2}&&&=&y_{1}\\
a_{2}x_{1}&+&b_{2}x_{2}&+&c_{2}x_{3}&=&y_{2}\\
&&a_{3}x_{2}&+&b_{3}x_{3}&=&y_{3}\\
\end{array}
$$

\begin{array}{l}
x_{1}=(y_{1}-c_{1}x_{2})/b_{1}\\
x_{3}=(y_{3}-a_{3}x_{2})/b_{3}\\
\end{array}

\begin{bmatrix}
  \hat{b}_{2}&\hat{c}_{2}   \\
  \hat{a}_{4}&\hat{b}_{4}&\hat{c}_{4} \\
  &\hat{a}_{6}&\hat{b}_{6} \\
  \end{bmatrix}
\begin{bmatrix}
 {x}_{2}\\ {x}_{4}\\ {x}_{6}
\end{bmatrix}=
\begin{bmatrix}
\hat{y}_{2}\\ \hat{y}_{4}\\ \hat{y}_{6}
\end{bmatrix}

\begin{array}{l}
x_{2}=(\hat{y}_{2}-\hat{c}_{2}x_{4})/\hat{b}_{2}\\
x_{6}=(\hat{y}_{6}-\hat{a}_{6}x_{4})/\hat{b}_{6}\\
\end{array}

code
```cpp
    int in = j - joffset;
    int ip = j + joffset;
    std::print( "in,j,ip = ({},{},{})\n", in, j, ip );
    x[ in ] = F[ in ];
    x[ ip ] = F[ ip ];
    for ( int k = 0; k < N; ++ k )
    {
        if ( k != in )
        {
            x[ in ] -= A[ in ][ k ] * x[ k ];
        }
        if ( k != ip )
        {
            x[ ip ] -= A[ ip ][ k ] * x[ k ];
        }
    }
    x[ in ] = x[ in ] / A[ in ][ in ];
    x[ ip ] = x[ ip ] / A[ ip ][ ip ];
```

$$
\begin{bmatrix}
  -2&1  && &&& \\
  1&-2&1 && & & \\
  &1&-2&1&& \\
  &&1&-2&1&& \\
  &&  &1&-2&1& \\
  &&  & &1&-2&1 \\
&&  & &&1&-2 \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3} \\x_{4} \\x_{5}\\x_{6}\\x_{7}
\end{bmatrix}=
\begin{bmatrix}
 1\\ 2\\ 3 \\4 \\5\\6\\7
\end{bmatrix}
$$

## 5 equation

$$
\begin{bmatrix}
  b_{1}&c_{1}  && & \\
  a_{2}&b_{2}&c_{2} &&  \\
  &a_{3}&b_{3}&c_{3}&\\
  &&a_{4}&b_{4}&c_{4}\\
  &&  &a_{5}&b_{5} \\
  \end{bmatrix}
\begin{bmatrix}
 x_{1}\\ x_{2}\\ x_{3} \\x_{4} \\x_{5}
\end{bmatrix}=
\begin{bmatrix}
 y_{1}\\ y_{2}\\ y_{3} \\y_{4} \\y_{5}
\end{bmatrix}
$$

$$
\begin{array}{l}
\alpha_{2}b_{1}x_{1}&+&\alpha_{2}c_{1}x_{2}&&&&&=&\alpha_{2}y_{1}\\
\beta_{2}a_{2}x_{1}&+&\beta_{2}b_{2}x_{2}&+&\beta_{2}c_{2}x_{3}&&&=&\beta_{2}y_{2}\\
&&\gamma_{2}a_{3}x_{2}&+&\gamma_{2}b_{3}x_{3}&+&\gamma_{2}c_{3}x_{4}&=&\gamma_{2}y_{3}\\
\end{array}
$$

$$
\begin{array}{l}
\alpha a_{i-1}x_{i-2}+\alpha b_{i-1}x_{i-1}+\alpha c_{i-1}x_{i}=\alpha_{2}y_{i-1}\\
\beta a_{i}x_{i-1}+\beta b_{i}x_{i}+\beta c_{i}x_{i+1}=\beta y_{i}\\
\gamma a_{i+1}x_{i}+\gamma b_{i+1}x_{i+1}+\gamma c_{i+1}x_{i+2}=\gamma y_{i+1}\\
\end{array}
$$

$$
\begin{array}{l}
\quad(\alpha a_{i-1})x_{i-2}\\
+(\alpha b_{i-1}+\beta a_{i})x_{i-1}\\
+(\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1})x_{i}\\
+(\beta c_{i}+\gamma b_{i+1})x_{i+1}\\
+(\gamma c_{i+1})x_{i+2}\\
=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}\\
\end{array}
$$

$$
\begin{bmatrix}
  \cdot&\cdot  && &&& \\
  \cdot&\cdot&\cdot && & & \\
  &a_{i-1}&b_{i-1}&c_{i-1}&& \\
  &&a_{i}&b_{i}&c_{i}&& \\
  &&  &a_{i+1}&b_{i+1}&c_{i+1}& \\
  &&  & &\cdot&\cdot&\cdot \\
&&  & &&\cdot&\cdot \\
  \end{bmatrix}
\begin{bmatrix}
 \cdot\\x_{i-2} \\ x_{i-1} \\x_{i} \\x_{i+1}\\x_{i+2}\\\cdot
\end{bmatrix}=
\begin{bmatrix}
  \cdot\\y_{i-2} \\ y_{i-1} \\y_{i} \\y_{i+1}\\y_{i+2}\\\cdot
\end{bmatrix}
$$

$$
\begin{array}{l}
\quad(\alpha b_{i-1}=\hat{a}_i)x_{i-2}\\
+(\alpha b_{i-1}+\beta a_{i}=0)x_{i-1}\\
+(\alpha c_{i-1}+\beta b_{i}+\gamma a_{i+1}=\hat{b}_i)x_{i}\\
+(\beta c_{i}+\gamma b_{i+1}=0)x_{i+1}\\
+(\gamma c_{i+1}=\hat{c}_i)x_{i+2}\\
=\alpha y_{i-1}+\beta y_{i}+\gamma y_{i+1}=\hat{y}_i\\
\end{array}
$$

$$
\begin{array}{l}
\beta=1\\
\alpha=-a_{i}/b_{i-1}\\
\gamma=-c_{i}/b_{i+1}\\
\hat{a}_i=\alpha b_{i-1}\\
\hat{c}_i=\gamma c_{i+1}\\
\hat{b}_i=\alpha c_{i-1}+b_{i}+\gamma a_{i+1}\\
\hat{y}_i=\alpha y_{i-1}+y_{i}+\gamma y_{i+1}\\
\hat{a}_ix_{i-2}+\hat{b}_i x_{i}+\hat{c}_ix_{i+2}=\hat{y}_i\\
\end{array}
$$

mpiexec -n 7
```powershell
 mpiexec -n 7 .\Debug\testprj.exe 
```

```
totalnodes=7, numrows=5, size=15
-2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
1 -2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 
0 1 -2 1 0 0 0 0 0 0 0 0 0 0 0 2 
0 0 1 -2 1 0 0 0 0 0 0 0 0 0 0 3 
0 0 0 1 -2 1 0 0 0 0 0 0 0 0 0 4 
0 0 0 0 1 -2 1 0 0 0 0 0 0 0 0 5 
0 0 0 0 0 1 -2 1 0 0 0 0 0 0 0 6 
0 0 0 0 0 0 1 -2 1 0 0 0 0 0 0 7 
0 0 0 0 0 0 0 1 -2 1 0 0 0 0 0 8 
0 0 0 0 0 0 0 0 1 -2 1 0 0 0 0 9 
0 0 0 0 0 0 0 0 0 1 -2 1 0 0 0 10 
0 0 0 0 0 0 0 0 0 0 1 -2 1 0 0 11 
0 0 0 0 0 0 0 0 0 0 0 1 -2 1 0 12 
0 0 0 0 0 0 0 0 0 0 0 0 1 -2 1 13 
0 0 0 0 0 0 0 0 0 0 0 0 0 1 -2 14 

-2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 -35 
0 -1 0 0.5 0 0 0 0 0 0 0 0 0 0 0 -70 
0 1 -2 1 0 0 0 0 0 0 0 0 0 0 0 -104 
0 0 0 -0.5 0 0 0 0.25 0 0 0 0 0 0 0 -136 
0 0 0 1 -2 1 0 0 0 0 0 0 0 0 0 -165 
0 0 0 0.5 0 -1 0 0.5 0 0 0 0 0 0 0 -190 
0 0 0 0 0 1 -2 1 0 0 0 0 0 0 0 -210 
0 0 0 0 0 0 0 -0.25 0 0 0 0 0 0 0 -224 
0 0 0 0 0 0 0 1 -2 1 0 0 0 0 0 -231 
0 0 0 0 0 0 0 0.5 0 -1 0 0.5 0 0 0 -230 
0 0 0 0 0 0 0 0 0 1 -2 1 0 0 0 -220 
0 0 0 0 0 0 0 0.25 0 0 0 -0.5 0 0 0 -200 
0 0 0 0 0 0 0 0 0 0 0 1 -2 1 0 -169 
0 0 0 0 0 0 0 0 0 0 0 0.5 0 -1 0 -126 
0 0 0 0 0 0 0 0 0 0 0 0 0 1 -2 -70 

refenence
x = -35 -70 -104 -136 -165 -190 -210 -224 -231 -230 -220 -200 -169 -126 -70
```

```
totalnodes=7, numrows=5, size=15
-2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
1 -2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 
0 1 -2 1 0 0 0 0 0 0 0 0 0 0 0 2 
0 0 1 -2 1 0 0 0 0 0 0 0 0 0 0 3 
0 0 0 1 -2 1 0 0 0 0 0 0 0 0 0 4 
0 0 0 0 1 -2 1 0 0 0 0 0 0 0 0 5 
0 0 0 0 0 1 -2 1 0 0 0 0 0 0 0 6 
0 0 0 0 0 0 1 -2 1 0 0 0 0 0 0 7 
0 0 0 0 0 0 0 1 -2 1 0 0 0 0 0 8 
0 0 0 0 0 0 0 0 1 -2 1 0 0 0 0 9 
0 0 0 0 0 0 0 0 0 1 -2 1 0 0 0 10 
0 0 0 0 0 0 0 0 0 0 1 -2 1 0 0 11 
0 0 0 0 0 0 0 0 0 0 0 1 -2 1 0 12 
0 0 0 0 0 0 0 0 0 0 0 0 1 -2 1 13 
0 0 0 0 0 0 0 0 0 0 0 0 0 1 -2 14 

int N = 15;
A[ 0 ][ 0 ] = -2.0;  A[ 0 ][ 1 ] = 1.0;
A[ N - 1 ][ N - 2 ] = 1.0; A[ N - 1 ][ N - 1 ] = -2.0;

for ( int i = 1; i < N - 1; ++ i )
{
	A[ i ][ i - 1 ] =   1.0;
	A[ i ][ i     ] = - 2.0;
	A[ i ][ i + 1 ] =   1.0;
}


rank(0~6)
-----------------------------------
0    1    2    3    4    5    6 
-----------------------------------
0
1
2    2
     3
     4    4
          5
	      6    6
	           7
		       8    8
			        9
					10   10
					     11
						 12   12
						      13
							  14
							  
for ( int iProc = 0; iProc < NProc; ++ iProc )
{
    //int loc = 2 * iProc + 1; //1,3,5,7,9,11,13
	int loc = 2 * iProc; //0,2,4,6,8,10,12
	
    for ( int i = 0; i < 3; ++ i )
    {
		int iloc = loc + i;
		if ( ( iloc - 1 ) >= 0 )
		{
            A[ iloc ][ iloc - 1 ] =  1.0;
		}
        A[ iloc ][ iloc     ] = -2.0;
		if ( ( iloc + 1 ) < N )
		{
            A[ iloc ][ iloc + 1 ] =  1.0;
		}
    }
}
```

```cpp
import std;
template<typename T>
void Print( std::vector<T> & x, const std::string & name = "vector" )
{
	std::print( "{} = ", name );
	for ( auto v: x )
	{
		std::print( "{} ", v );
	}
	std::println();
}

void Print( std::vector<std::vector<double>> & a, const std::string & name = "matrix" )
{
	int NI = a.size();
	for ( int i = 0; i < NI; ++ i )
	{
		int NJ = a[ i ].size();
		for ( int j = 0; j < NJ; ++ j )
		{
			std::print( "{:2.0f} ", a[ i ][ j ] );
		}
		std::println();
	}
	std::println();
}

void SetMatrixValue( int N, int nProc )
{
	std::vector<std::vector<double>> A;
	A.resize( N );
	for ( int i = 0; i < N; ++ i )
	{
		A[ i ].resize( N );
	}
	for ( int iProc = 0; iProc < nProc; ++ iProc )
	{
		//int loc = 2 * iProc + 1; //1,3,5,7,9,11,13
		int loc = 2 * iProc; //0,2,4,6,8,10,12
		for ( int i = 0; i < 3; ++ i )
		{
			int iloc = loc + i;
			if ( ( iloc - 1 ) >= 0 )
			{
				A[ iloc ][ iloc - 1 ] =  1.0;
			}
			A[ iloc ][ iloc     ] = -2.0;
			if ( ( iloc + 1 ) < N )
			{
				A[ iloc ][ iloc + 1 ] =  1.0;
			}
		}
	}

	Print( A, "matrix A" );
}

void SetMatrixValueNew( int N, int nProc )
{
	std::vector<std::vector<std::vector<double>>> AList;
	AList.resize( nProc );
	for ( int iProc = 0; iProc < nProc; ++ iProc )
	{
		int nRow = 3;
		AList[ iProc ].resize( nRow );
		for ( int i = 0; i < nRow; ++ i )
		{
			AList[ iProc ][ i ].resize( N );
		}

	}
	for ( int iProc = 0; iProc < nProc; ++ iProc )
	{
		std::vector<std::vector<double>> & A = AList[ iProc ];
		//int loc = 2 * iProc + 1; //1,3,5,7,9,11,13
		int loc = 2 * iProc; //0,2,4,6,8,10,12
		std::vector<int> global_locs( 3 );
		for ( int i = 0; i < 3; ++ i )
		{
			int iloc = loc + i;
			global_locs[ i ] = iloc;
			if ( ( iloc - 1 ) >= 0 )
			{
				A[ i ][ iloc - 1 ] =  1.0;
			}
			A[ i ][ iloc     ] = -2.0;
			if ( ( iloc + 1 ) < N )
			{
				A[ i ][ iloc + 1 ] =  1.0;
			}
		}
		std::print("iProc={}\n", iProc );
		Print( global_locs, "global_locs" );
		Print( A, "matrix A" );
	}
}

int main( int argc, char ** argv )
{
	int N = 15;
	int nProc = 7;

	SetMatrixValue( N, nProc );
	SetMatrixValueNew( N, nProc );

    return 0;
}
```

```powershell
-2  1  0  0  0  0  0  0  0  0  0  0  0  0  0
 1 -2  1  0  0  0  0  0  0  0  0  0  0  0  0
 0  1 -2  1  0  0  0  0  0  0  0  0  0  0  0
 0  0  1 -2  1  0  0  0  0  0  0  0  0  0  0
 0  0  0  1 -2  1  0  0  0  0  0  0  0  0  0
 0  0  0  0  1 -2  1  0  0  0  0  0  0  0  0
 0  0  0  0  0  1 -2  1  0  0  0  0  0  0  0
 0  0  0  0  0  0  1 -2  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  1 -2  1  0  0  0  0  0
 0  0  0  0  0  0  0  0  1 -2  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  1 -2  1  0  0  0
 0  0  0  0  0  0  0  0  0  0  1 -2  1  0  0
 0  0  0  0  0  0  0  0  0  0  0  1 -2  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  1 -2  1
 0  0  0  0  0  0  0  0  0  0  0  0  0  1 -2

iProc=0
global_locs = 0 1 2
-2  1  0  0  0  0  0  0  0  0  0  0  0  0  0
 1 -2  1  0  0  0  0  0  0  0  0  0  0  0  0
 0  1 -2  1  0  0  0  0  0  0  0  0  0  0  0

iProc=1
global_locs = 2 3 4
 0  1 -2  1  0  0  0  0  0  0  0  0  0  0  0
 0  0  1 -2  1  0  0  0  0  0  0  0  0  0  0
 0  0  0  1 -2  1  0  0  0  0  0  0  0  0  0

iProc=2
global_locs = 4 5 6
 0  0  0  1 -2  1  0  0  0  0  0  0  0  0  0
 0  0  0  0  1 -2  1  0  0  0  0  0  0  0  0
 0  0  0  0  0  1 -2  1  0  0  0  0  0  0  0

iProc=3
global_locs = 6 7 8
 0  0  0  0  0  1 -2  1  0  0  0  0  0  0  0
 0  0  0  0  0  0  1 -2  1  0  0  0  0  0  0
 0  0  0  0  0  0  0  1 -2  1  0  0  0  0  0

iProc=4
global_locs = 8 9 10
 0  0  0  0  0  0  0  1 -2  1  0  0  0  0  0
 0  0  0  0  0  0  0  0  1 -2  1  0  0  0  0
 0  0  0  0  0  0  0  0  0  1 -2  1  0  0  0

iProc=5
global_locs = 10 11 12
 0  0  0  0  0  0  0  0  0  1 -2  1  0  0  0
 0  0  0  0  0  0  0  0  0  0  1 -2  1  0  0
 0  0  0  0  0  0  0  0  0  0  0  1 -2  1  0

iProc=6
global_locs = 12 13 14
 0  0  0  0  0  0  0  0  0  0  0  1 -2  1  0
 0  0  0  0  0  0  0  0  0  0  0  0  1 -2  1
 0  0  0  0  0  0  0  0  0  0  0  0  0  1 -2
```

```cpp
import std;

int main( int argc, char ** argv )
{
	for ( int nprocs = 1; nprocs <= 7; ++ nprocs )
	{
		int N = (int)std::pow( 2, std::log2( nprocs + 1 ) + 1 ) - 1;
		std::print( "nprocs = {}, N = {:4}, (N-1)/2 = {}\n", nprocs, N, ( N - 1 ) / 2 );
	}

    return 0;
}
```

output
```powershell
nprocs = 1, N =    3, (N-1)/2 = 1
nprocs = 2, N =    5, (N-1)/2 = 2
nprocs = 3, N =    7, (N-1)/2 = 3
nprocs = 4, N =    8, (N-1)/2 = 3
nprocs = 5, N =   11, (N-1)/2 = 5
nprocs = 6, N =   13, (N-1)/2 = 6
nprocs = 7, N =   15, (N-1)/2 = 7
```

serial N=7
```
Cyclic reduction level = 0
in,j,ip = (0,1,2)

in,j,ip = (2,3,4)

in,j,ip = (4,5,6)

Cyclic reduction level = 1
in,j,ip = (1,3,5)

x[3] = -24
Back substitution level = 1
in,j,ip = (1,3,5)
Back substitution level = 0
in,j,ip = (0,1,2)
in,j,ip = (2,3,4)
in,j,ip = (4,5,6)
x = -7 -14 -20 -24 -25 -22 -14
```

serial N=7 detail
```
matrix A 0 =
-2.00  1.00  0.00  0.00  0.00  0.00  0.00
 1.00 -2.00  1.00  0.00  0.00  0.00  0.00
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00
 0.00  0.00  1.00 -2.00  1.00  0.00  0.00
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00
 0.00  0.00  0.00  0.00  1.00 -2.00  1.00
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00

vector F = 0 1 2 3 4 5 6
Cyclic reduction level = 0
in,j,ip = (0,1,2)
A[1][0]=1
A[1][2]=1
A[0][0]=-2
A[2][2]=-2
alpha = -0.5, gamma = -0.5
j,k=(1,0) in,k=(0,0) ip,k=(2,0)
j,k=(1,1) in,k=(0,1) ip,k=(2,1)
j,k=(1,2) in,k=(0,2) ip,k=(2,2)
j,k=(1,3) in,k=(0,3) ip,k=(2,3)
j,k=(1,4) in,k=(0,4) ip,k=(2,4)
j,k=(1,5) in,k=(0,5) ip,k=(2,5)
j,k=(1,6) in,k=(0,6) ip,k=(2,6)

in,j,ip = (2,3,4)
A[3][2]=1
A[3][4]=1
A[2][2]=-2
A[4][4]=-2
alpha = -0.5, gamma = -0.5
j,k=(3,0) in,k=(2,0) ip,k=(4,0)
j,k=(3,1) in,k=(2,1) ip,k=(4,1)
j,k=(3,2) in,k=(2,2) ip,k=(4,2)
j,k=(3,3) in,k=(2,3) ip,k=(4,3)
j,k=(3,4) in,k=(2,4) ip,k=(4,4)
j,k=(3,5) in,k=(2,5) ip,k=(4,5)
j,k=(3,6) in,k=(2,6) ip,k=(4,6)

in,j,ip = (4,5,6)
A[5][4]=1
A[5][6]=1
A[4][4]=-2
A[6][6]=-2
alpha = -0.5, gamma = -0.5
j,k=(5,0) in,k=(4,0) ip,k=(6,0)
j,k=(5,1) in,k=(4,1) ip,k=(6,1)
j,k=(5,2) in,k=(4,2) ip,k=(6,2)
j,k=(5,3) in,k=(4,3) ip,k=(6,3)
j,k=(5,4) in,k=(4,4) ip,k=(6,4)
j,k=(5,5) in,k=(4,5) ip,k=(6,5)
j,k=(5,6) in,k=(4,6) ip,k=(6,6)

Cyclic reduction level = 1
in,j,ip = (1,3,5)
A[3][1]=0.5
A[3][5]=0.5
A[1][1]=-1
A[5][5]=-1
alpha = -0.5, gamma = -0.5
j,k=(3,0) in,k=(1,0) ip,k=(5,0)
j,k=(3,1) in,k=(1,1) ip,k=(5,1)
j,k=(3,2) in,k=(1,2) ip,k=(5,2)
j,k=(3,3) in,k=(1,3) ip,k=(5,3)
j,k=(3,4) in,k=(1,4) ip,k=(5,4)
j,k=(3,5) in,k=(1,5) ip,k=(5,5)
j,k=(3,6) in,k=(1,6) ip,k=(5,6)

matrix A after cyclic reduction =
-2.00  1.00  0.00  0.00  0.00  0.00  0.00
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00
 0.00  0.00  0.00 -0.50  0.00  0.00  0.00
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00

vector F after cyclic reduction = 0 2 2 12 4 10 6
F[3] = 12, A[3][3]=-0.5
x[3] = -24
Back substitution level = 1
in,j,ip = (1,3,5)
x[1] = -14, x[5] = -22
Back substitution level = 0
in,j,ip = (0,1,2)
x[0] = -7, x[2] = -20
in,j,ip = (2,3,4)
x[2] = -20, x[4] = -25
in,j,ip = (4,5,6)
x[4] = -25, x[6] = -14
x = -7 -14 -20 -24 -25 -22 -14
xx = -7 -14 -20 -24 -25 -22 -14
ff = 0 1 2 3 4 5 6
FF = 0 1 2 3 4 5 6
```

Back substitution N=7
```cpp
int index = ( N - 1 ) / 2; //(7-1)/2=3
0
1----        x[1]
2            |
3---- x[3]---|
4            |
5----        x[5]
6

level = 1;
int joffset = std::pow( 2, level );//2^1 = 2
int in = j - joffset; // 3 - 2 = 1
int ip = j + joffset; // 3 + 2 = 5
j =3;
in=1;
ip=5;
x[ in ] = F[ in ];
for ( int k = 0; k < N; ++ k )
{
    if ( k != in )
    {
        x[ in ] -= A[ in ][ k ] * x[ k ];
    }
}

x[ in ] = ( y[ in ] - a[ in ] * x[ in - joffset ] - c[ in ] * x[ in + joffset ] ) / b[ in ];
x[ in ] = ( y[ in ] - A[ in ][ in - joffset ] * x[ in - joffset ] - A[ in ][ in + joffset ] * x[ in + joffset ] ) / A[ in ][ in ];

x[ ip ] = ( y[ ip ] - a[ ip ] * x[ ip - joffset ] - c[ ip ] * x[ ip + joffset ] ) / b[ ip ];
x[ ip ] = ( y[ ip ] - A[ ip ][ ip - joffset ] * x[ ip - joffset ] - A[ ip ][ ip + joffset ] * x[ ip + joffset ] ) / A[ ip ][ ip ];
```

Part 4 - Solving for odd rows
```cpp
//Part 4 - Solving for odd rows

for ( int k = 0; k < Parallel::nprocs; ++ k )
{
    A[ 0 ][ N ] -= A[ 0 ][ 2 * k + 1 ] * x[ k ];
    A[ 2 ][ N ] -= A[ 2 ][ 2 * k + 1 ] * x[ k ];
}
A[ 0 ][ N ] = A[ 0 ][ N ] / A[ 0 ][ 2 * Parallel::pid ];
A[ 1 ][ N ] = x[ Parallel::pid ];
A[ 2 ][ N ] = A[ 2 ][ N ] / A[ 2 ][ 2 * Parallel::pid + 2 ];

-------------------------------------------------------
Parallel::pid
0
2 * Parallel::pid
0
A[0][0]            
2 * Parallel::pid + 2
2
A[2][2]

-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00  2.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
-------------------------------------------------------
Parallel::pid
1
2 * Parallel::pid
2
A[0][2]            
2 * Parallel::pid + 2
4
A[2][4]

 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00 -0.50  0.00  0.00  0.00 12.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 10.00 
-------------------------------------------------------
Parallel::pid
2
2 * Parallel::pid
4
A[0][4]
2 * Parallel::pid + 2
6
A[2][6]

 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 10.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
-------------------------------------------------------
```

Part 2 - Cyclic reduction
```cpp
int offset = std::pow( 2, level );
int step = std::pow( 2, level + 1 );
for ( int j = 0; j < numactivep; ++ j )
{
    if ( Parallel::pid == activep[ j ] )
    {
        int index1 = 2 * Parallel::pid + 1 - offset;
        int index2 = 2 * Parallel::pid + 1 + offset;
		
        double alpha = A[ 1 ][ index1 ] / A[ 3 ][ index1 ];
        double gamma = A[ 1 ][ index2 ] / A[ 4 ][ index2 ];
        for ( int k = 0; k < N + 1; ++ k )
        {
            A[ 1 ][ k ] -= ( alpha * A[ 3 ][ k ] + gamma * A[ 4 ][ k ] );
        }
        if ( numactivep > 1 )
        {
            if ( j == 0 )
            {
                MPI_Send( A[ 1 ].data(), N + 1, MPI_DOUBLE, activep[ 1 ], 0, MPI_COMM_WORLD );
            }
            else if ( j == numactivep - 1 )
            {
                MPI_Send( A[ 1 ].data(), N + 1, MPI_DOUBLE, activep[ numactivep - 2 ], 1, MPI_COMM_WORLD );
            }
            else if ( j % 2 == 0 )
            {
                MPI_Send( A[ 1 ].data(), N + 1, MPI_DOUBLE, activep[ j - 1 ], 1, MPI_COMM_WORLD );
                MPI_Send( A[ 1 ].data(), N + 1, MPI_DOUBLE, activep[ j + 1 ], 0, MPI_COMM_WORLD );
            }
            else
            {
                MPI_Recv( A[ 3 ].data(), N + 1, MPI_DOUBLE, activep[ j - 1 ], 0, MPI_COMM_WORLD, &status );
                MPI_Recv( A[ 4 ].data(), N + 1, MPI_DOUBLE, activep[ j + 1 ], 1, MPI_COMM_WORLD, &status );
            }
        }
    }
}
level = 0;
offset = 1;
int index1 = 2 * Parallel::pid + 1 - offset;
int index2 = 2 * Parallel::pid + 1 + offset;
double alpha = A[ 1 ][ index1 ] / A[ 3 ][ index1 ];
double gamma = A[ 1 ][ index2 ] / A[ 4 ][ index2 ];
for ( int k = 0; k < N + 1; ++ k )
{
    A[ 1 ][ k ] -= ( alpha * A[ 3 ][ k ] + gamma * A[ 4 ][ k ] );
}
---------------------------------------------------------
pid = 0
index1 = 0;
index2 = 2;

Matrix A 1 = 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 1.00 -2.00  1.00  0.00  0.00  0.00  0.00  1.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 

alpha = A[ 1 ][ 0 ] / A[ 3 ][ 0 ];
gamma = A[ 1 ][ 2 ] / A[ 3 ][ 2 ];

N=7
for ( int k = 0; k < 8; ++ k )
{
    A[ 1 ][ k ] -= ( alpha * A[ 3 ][ k ] + gamma * A[ 4 ][ k ] );
}
 
 Matrix A 2 = 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00  2.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
---------------------------------------------------------
pid = 1
index1 = 2;
index2 = 4;

Matrix A 1 = 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  1.00 -2.00  1.00  0.00  0.00  3.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 

alpha = A[ 1 ][ 2 ] / A[ 3 ][ 2 ];
gamma = A[ 1 ][ 4 ] / A[ 3 ][ 4 ];

Matrix A 2 = 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00 -0.50  0.00  0.00  0.00 12.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 10.00 
---------------------------------------------------------
pid = 2
index1 = 4;
index2 = 6;

Matrix A 1 = 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.00  1.00 -2.00  1.00  5.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 

alpha = A[ 1 ][ 4 ] / A[ 3 ][ 4 ];
gamma = A[ 1 ][ 6 ] / A[ 3 ][ 6 ];

Matrix A 2 = 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 10.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
---------------------------------------------------------
```

## Parallel::nprocs=7,N=15
```
Parallel::nprocs=7,N=15

stage 0
+----|----------------------------+
+pid |0   1   2   3   4   5   6   +
+----|----------------------------+
+row |0   2   4   6   8   10  12  +
+    |1   3   5   7   9   11  13  +
+    |2   4   6   8   10  12  14  +
+++++++++++++++++++++++++++++++++++	

stage 1
+----|----------------------------+
+pid |0   1   2   3   4   5   6   +
+----|----------------------------+
+row |0   2   4   6   8   10  12  +
+    |1*  3*  5*  7*  9*  11* 13* +
+    |2   4   6   8   10  12  14  +
+++++++++++++++++++++++++++++++++++	

pid=0,row=0 ,1 ,2 ->1*
pid=1,row=2 ,3 ,4 ->3*
pid=2,row=4 ,5 ,6 ->5*
pid=3,row=6 ,7 ,8 ->7*
pid=4,row=8 ,9 ,10->9*
pid=5,row=10,11,12->11*
pid=6,row=12,13,14->13*

stage 2
+----|-----------------------------+
+pid |0   1   2   3   4   5    6   +
+----|-----------------------------+
+row |0   2   4   6   8   10   12  +
+    |1*  3** 5*  7** 9*  11** 13* +
+    |2   4   6   8   10  12   14  +
++++++++++++++++++++++++++++++++++++

pid=0,row=1*
pid=1,row=3*  -> 3**
pid=2,row=5*

pid=2,row=5*
pid=3,row=7*  -> 7**
pid=4,row=9*

pid=4,row=9 *
pid=5,row=11*  -> 11**
pid=6,row=13*

stage 3
+----|------------------------------+
+pid |0   1   2   3    4   5    6   +
+----|------------------------------+
+row |0   2   4   6    8   10   12  +
+    |1*  3** 5*  7*** 9*  11** 13* +
+    |2   4   6   8    10  12   14  +
+++++++++++++++++++++++++++++++++++++

pid=1,row=3 **
pid=3,row=7 **  -> 7***
pid=5,row=11**

stage 4
N=15
int index = ( N - 1 ) / 2 = 7;
row = 7
pid=3,row=7***->x[7]

stage 5
nprocs=7

for ( int level = std::log2( N + 1 ) - 2; level >= 0; -- level )
N+1=16
std::log2( N + 1 )=std::log2( 16 )=4
std::log2( N + 1 ) - 2 = 2

-------------------------------------------------
level = 2
-------------------------------------------------
int row_offset = std::pow(2,level)=std::pow(2,2)=4;
int row_step = std::pow(2,level+1)=std::pow(2,3)=8;
int row_start = row_step - 1=7;
row = row_start = 7
int row_in = row - row_offset=7-4=3;
int row_ip = row + row_offset=7+4=11;

xx[ in ] = ( y[ in ] - a[ in ] * xx[ in - row_offset ] - c[ in ] * xx[ in + row_offset ] ) / b[ in ];
xx[ ip ] = ( y[ ip ] - a[ ip ] * xx[ ip - row_offset ] - c[ ip ] * xx[ ip + row_offset ] ) / b[ ip ];
xx[ 3 ] = ( y[ 3 ] - a[ 3 ] * xx[ -1 ] - c[ 3 ] * xx[ 7 ] ) / b[ 3 ];
xx[ 11 ] = ( y[ 1 ] - a[ 1 ] * xx[ 7 ] - c[ 11 ] * xx[ 15 ] ) / b[ 11 ];

pid=1,row=3** -> x[3]
pid=5,row=11** -> x[11]

-----------------------------
solved:x3,x7,x11
-----------------------------

-------------------------------------------------
level = 1
-------------------------------------------------
int row_offset = std::pow(2,level)=std::pow(2,2)=2;
int row_step = std::pow(2,level+1)=std::pow(2,3)=4;
int row_start = row_step-1=3;
for ( int row = row_start; row < N; row = row + row_step )
----------------------------
row = row_start = 3 //3,7,11
----------------------------

+----|------------------------------+
+pid |0   1   2   3    4   5    6   +
+----|------------------------------+
+row |0   2   4   6    8   10   12  +
+    |1*  3** 5*  7*** 9*  11** 13* +
+    |2   4   6   8    10  12   14  +
+++++++++++++++++++++++++++++++++++++
int row_offset = 2;
int row_in = row - row_offset=3-2=1;
int row_ip = row + row_offset=3+2=5;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 1 ] = ( y[ 1 ] - a[ 1 ] * xx[ -1 ] - c[ 1 ] * xx[ 3 ] ) / b[ 1 ];
xx[ 5 ] = ( y[ 5 ] - a[ 5 ] * xx[ 3  ] - c[ 5 ] * xx[ 7 ] ) / b[ 5 ];

pid=0,row=1* -> x[1]
pid=2,row=5* -> x[5]

----------------------------
row = 7
----------------------------
int row_offset = 2;
int row_in = row - row_offset=7-2=5;
int row_ip = row + row_offset=7+2=9;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 5 ] = ( y[ 5 ] - a[ 5 ] * xx[ 3 ] - c[ 5 ] * xx[ 7  ] ) / b[ 5 ];
xx[ 9 ] = ( y[ 9 ] - a[ 9 ] * xx[ 7 ] - c[ 9 ] * xx[ 11 ] ) / b[ 9 ];

pid=2,row=5* -> x[5]
pid=4,row=9* -> x[9]

----------------------------
row = 11
----------------------------
int row_offset = 2;
int row_in = row - row_offset=11-2=9;
int row_ip = row + row_offset=11+2=13;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 9  ] = ( y[ 9  ] - a[ 9  ] * xx[ 7 ] - c[ 9  ] * xx[ 11 ] ) / b[ 9  ];
xx[ 13 ] = ( y[ 13 ] - a[ 13 ] * xx[ 11 ]- c[ 13 ] * xx[ 15 ] ) / b[ 13 ];
                              
pid=4,row=9*  -> x[9 ]
pid=6,row=13* -> x[13]

-----------------------------
solved:x3,x7,x11
solved:x1,x5,x5,x9,x9,x13
solved:x1,x3,x5,x7,x9,x11,x13
-----------------------------

-------------------------------------------------
level = 0
-------------------------------------------------
int row_offset = std::pow(2,level)=std::pow(2,2)=1;
int row_step = std::pow(2,level+1)=std::pow(2,3)=2;
int row_start = row_step-1=1;
for ( int row = row_start; row < N; row = row + row_step )
--------------------------------------
row = row_start = 1 //1,3,5,7,9,11,13
--------------------------------------
row = 1

int row_offset = 1;
int row_in = row - row_offset=1-1=0;
int row_ip = row + row_offset=1+1=2;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 0 ] = ( y[ 0 ] - a[ 0 ] * xx[ -1 ] - c[ 0 ] * xx[ 1 ] ) / b[ 0 ];
xx[ 2 ] = ( y[ 2 ] - a[ 2 ] * xx[ 1 ] - c[ 2 ] * xx[ 3 ] ) / b[ 2 ];

pid=0,row=0 -> x[0]
pid=0,row=2 -> x[2]

+----|------------------------------+
+pid |0   1   2   3    4   5    6   +
+----|------------------------------+
+row |0   2   4   6    8   10   12  +
+    |1*  3** 5*  7*** 9*  11** 13* +
+    |2   4   6   8    10  12   14  +
+++++++++++++++++++++++++++++++++++++

row = 3

int row_offset = 1;
int row_in = row - row_offset=3-1=2;
int row_ip = row + row_offset=3+1=4;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 2 ] = ( y[ 2 ] - a[ 2 ] * xx[ 1 ] - c[ 2 ] * xx[ 3 ] ) / b[ 2 ];
xx[ 4 ] = ( y[ 4 ] - a[ 4 ] * xx[ 3 ] - c[ 4 ] * xx[ 5 ] ) / b[ 4 ];
pid=1,row=2 -> x[2]
pid=1,row=4 -> x[4]

row = 5

int row_offset = 1;
int row_in = row - row_offset=5-1=4;
int row_ip = row + row_offset=5+1=6;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 4 ] = ( y[ 4 ] - a[ 4 ] * xx[ 3 ] - c[ 4 ] * xx[ 5 ] ) / b[ 4 ];
xx[ 6 ] = ( y[ 6 ] - a[ 6 ] * xx[ 5 ] - c[ 6 ] * xx[ 7 ] ) / b[ 6 ];

pid=2,row=4 -> x[4]
pid=2,row=6 -> x[6]
                             
row = 7

int row_offset = 1;
int row_in = row - row_offset=7-1=6;
int row_ip = row + row_offset=7+1=8;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 6 ] = ( y[ 6 ] - a[ 6 ] * xx[ 5 ] - c[ 6 ] * xx[ 7 ] ) / b[ 6 ];
xx[ 8 ] = ( y[ 8 ] - a[ 8 ] * xx[ 7 ] - c[ 8 ] * xx[ 9 ] ) / b[ 8 ];

pid=3,row=6 -> x[6]
pid=3,row=8 -> x[8]

row = 9

int row_offset = 1;
int row_in = row - row_offset=9-1=8;
int row_ip = row + row_offset=9+1=10;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 8  ] = ( y[ 8  ] - a[ 8  ] * xx[ 7 ] - c[ 8  ] * xx[ 9  ] ) / b[ 8 ];
xx[ 10 ] = ( y[ 10 ] - a[ 10 ] * xx[ 9 ] - c[ 10 ] * xx[ 11 ] ) / b[ 10 ];

pid=4,row=8 -> x[8]
pid=4,row=10-> x[10]

row = 11

int row_offset = 1;
int row_in = row - row_offset=11-1=10;
int row_ip = row + row_offset=11+1=12;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 10 ] = ( y[ 10 ] - a[ 10 ] * xx[ 9  ] - c[ 10 ] * xx[ 11 ] ) / b[ 10 ];
xx[ 12 ] = ( y[ 12 ] - a[ 12 ] * xx[ 11 ] - c[ 12 ] * xx[ 13 ] ) / b[ 12 ];

pid=5,row=10-> x[10]
pid=5,row=12-> x[12]

row = 13

int row_offset = 1;
int row_in = row - row_offset=13-1=12;
int row_ip = row + row_offset=13+1=14;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 12 ] = ( y[ 12 ] - a[ 12 ] * xx[ 11 ] - c[ 12 ] * xx[ 13 ] ) / b[ 12 ];
xx[ 14 ] = ( y[ 14 ] - a[ 14 ] * xx[ 13 ] - c[ 14 ] * xx[ 15 ] ) / b[ 14 ];
                             
pid=6,row=12-> x[12]
pid=6,row=14-> x[14]
```

## p vs N vs nprocs
```cpp
import std;

int main( int argc, char ** argv )
{
	for ( int p = 0; p <= 10; ++ p )
	{
		int N = std::pow( 2, p ) - 1;
		int nprocs = ( N + 1 ) / 2 - 1;
		std::print( "p = {:3}, N = {:5}, nprocs = {:5}\n", p, N, nprocs );
	}

    return 0;
}
```

output
```
p =   0, N =     0, nprocs =    -1
p =   1, N =     1, nprocs =     0
p =   2, N =     3, nprocs =     1
p =   3, N =     7, nprocs =     3
p =   4, N =    15, nprocs =     7
p =   5, N =    31, nprocs =    15
p =   6, N =    63, nprocs =    31
p =   7, N =   127, nprocs =    63
p =   8, N =   255, nprocs =   127
p =   9, N =   511, nprocs =   255
p =  10, N =  1023, nprocs =   511
```


parallel nprocs=3,N=7
```cpp
N=std::pow(2,3)-1=7=pow(2,P)-1;
P=3;
int N = (int)std::pow( 2, std::log2( Parallel::nprocs + 1 ) + 1 ) - 1;
N+1=pow( 2, std::log2( Parallel::nprocs + 1 ) + 1 )=std::pow(2,3);
std::log2( Parallel::nprocs + 1 ) + 1 = P = 3;
std::log2( Parallel::nprocs + 1 ) = 2 = P - 1;
std::pow( 2, std::log2( Parallel::nprocs + 1 ) )= std::pow( 2, P-1 );
Parallel::nprocs + 1 = std::pow( 2, P-1 );
Parallel::nprocs = std::pow( 2, P-1 ) - 1;

stage 0
+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1   3   5   +
+    |2   4   6   +
+++++++++++++++++++

stage 1
+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1*  3*  5*  +
+    |2   4   6   +
+++++++++++++++++++

stage 1 local index
+----|--------------------+
+pid |0      1      2     +
+----|--------------------+
+row |0      2      4     + x[0]
+    |1*(0)  3*(1)  5*(2) + x[1]
+    |2      4      6     + x[2]
+++++++++++++++++++++++++++

pid=0,row=0 ,1 ,2 ->1*
pid=1,row=2 ,3 ,4 ->3*
pid=2,row=4 ,5 ,6 ->5*

stage 2
+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1*  3** 5*  +
+    |2   4   6   +
+++++++++++++++++++

pid=0,row=1*
pid=1,row=3*  -> 3**
pid=2,row=5*

stage 4
N=7
int index = ( N - 1 ) / 2 = 3;
row = 3
pid=1,row=3**->x[3]


stage 5
nprocs=3

for ( int level = std::log2( N + 1 ) - 2; level >= 0; -- level )
7+1=8
std::log2( N + 1 )=std::log2( 8 )=3
std::log2( N + 1 ) - 2 = 1


+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1*  3** 5*  +
+    |2   4   6   +
+++++++++++++++++++

-------------------------------------------------
level = 1
-------------------------------------------------
int row_offset = std::pow(2,level)=std::pow(2,1)=2;
int row_step = std::pow(2,level+1)=std::pow(2,2)=4;
int row_start = row_step-1=3;
N=7
for ( int row = row_start; row < N; row = row + row_step )
----------------------------
row = row_start = 3 //3
----------------------------
int row_in = row - row_offset=3-2=1;
int row_ip = row + row_offset=3+2=5;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 1 ] = ( y[ 1 ] - a[ 1 ] * xx[ -1 ] - c[ 1 ] * xx[ 3 ] ) / b[ 1 ];
xx[ 5 ] = ( y[ 5 ] - a[ 5 ] * xx[  3 ] - c[ 5 ] * xx[ 7 ] ) / b[ 5 ];

pid=0,row=1 -> x[1]
pid=2,row=5 -> x[5]

solved:x1,x3,x5
                             
-------------------------------------------------
level = 0
-------------------------------------------------
int row_offset = std::pow(2,level)=std::pow(2,0)=1;
int row_step = std::pow(2,level+1)=std::pow(2,1)=2;
int row_start = row_step-1=1;
N=7
for ( int row = row_start; row < N; row = row + row_step )
----------------------------
row = row_start = 1 //1,3,5
----------------------------
int row_in = row - row_offset=1-1=0;
int row_ip = row + row_offset=1+1=2;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];
xx[ 0 ] = ( y[ 0 ] - a[ 0 ] * xx[ -1 ] - c[ 0 ] * xx[ 1 ] ) / b[ 0 ];
xx[ 2 ] = ( y[ 2 ] - a[ 2 ] * xx[ 1  ] - c[ 2 ] * xx[ 3 ] ) / b[ 2 ];

pid=0,row=0 -> x[0]
pid=0,row=2 -> x[2]

int row_offset = std::pow(2,level)=std::pow(2,0)=1;
int row_step = std::pow(2,level+1)=std::pow(2,1)=2;
int row_start = row_step-1=1;
N=7
for ( int row = row_start; row < N; row = row + row_step )
----------------------------
row = row_start = 3 //1,3,5
----------------------------
int row_in = row - row_offset=3-1=2;
int row_ip = row + row_offset=3+1=4;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 2 ] = ( y[ 2 ] - a[ 2 ] * xx[ 1 ] - c[ 2 ] * xx[ 3 ] ) / b[ 2 ];
xx[ 4 ] = ( y[ 4 ] - a[ 4 ] * xx[ 3 ] - c[ 4 ] * xx[ 5 ] ) / b[ 4 ];

pid=1,row=2 -> x[2]
pid=1,row=4 -> x[4]


int row_offset = std::pow(2,level)=std::pow(2,0)=1;
int row_step = std::pow(2,level+1)=std::pow(2,1)=2;
int row_start = row_step-1=1;
N=7
for ( int row = row_start; row < N; row = row + row_step )
----------------------------
row = row_start = 5 //1,3,5
----------------------------
int row_in = row - row_offset=5-1=4;
int row_ip = row + row_offset=5+1=6;

xx[ row_in ] = ( y[ row_in ] - a[ row_in ] * xx[ row_in - row_offset ]
                             - c[ row_in ] * xx[ row_in + row_offset ] ) / b[ row_in ];
xx[ row_ip ] = ( y[ row_ip ] - a[ row_ip ] * xx[ row_ip - row_offset ]
                             - c[ row_ip ] * xx[ row_ip + row_offset ] ) / b[ row_ip ];

xx[ 4 ] = ( y[ 4 ] - a[ 4 ] * xx[ 3 ] - c[ 4 ] * xx[ 5 ] ) / b[ 4 ];
xx[ 6 ] = ( y[ 6 ] - a[ 6 ] * xx[ 5 ] - c[ 6 ] * xx[ 7 ] ) / b[ 6 ];
                             
pid=2,row=4 -> x[4]
pid=2,row=6 -> x[6]
```

```cpp
N=7
N+1=8
std::log2( N + 1 ) - 3=0;
for ( int level = std::log2( N + 1 ) - 3; level >= 0; -- level )
for ( int level = 0; level >= 0; -- level )
{
    logFile << "Back substitution level = " << level << "\n";
    int offset = std::pow( 2, level )=1;
    int step = std::pow( 2, level + 1 )=2;

    logFile << "offset = " << offset << " step = " << step << "\n";

    tmp = x[ Parallel::pid ];
    MPI_Allgather( &tmp, 1, MPI_DOUBLE, x.data(), 1, MPI_DOUBLE, MPI_COMM_WORLD );
    Print( x, "vector x 111" );
    logFile << "activep[ 0 ] = " << activep[ 0 ] << " activep[ 0 ] - offset = " << activep[ 0 ] - offset;
    logFile << " Parallel::nprocs = " << Parallel::nprocs << "\n";
    Print( activep, "vector activep 000" );
    numactivep = 0;
    for ( int j = activep[ 0 ] - offset; j < Parallel::nprocs; j = j + step )
	for ( int j = 0; j < 3; j = j + 2 )//j=0,2
    {
        logFile << "j = " << j << " numactivep = " << numactivep << "\n";
        logFile << "000 activep[" << numactivep << "] = " << activep[ numactivep ] << "\n";
        activep[ numactivep ++ ] = j;
        logFile << "111 activep[" << numactivep << "] = " << activep[ numactivep ] << "\n";
    }
	activep = [0,2];
    logFile << "numactivep = " << numactivep << "\n";
    Print( activep, "vector activep 111" );

    for ( int j = 0; j < numactivep; ++ j )
    {
        logFile << "j = " << j << " numactivep = " << numactivep;
        logFile << " activep[" << j << "] = " << activep[ j ] << " Parallel::pid = " << Parallel::pid << "\n";
            
        if ( Parallel::pid == activep[ j ] )
        {
            logFile << "000 x[" << Parallel::pid << "] = " << x[ Parallel::pid ] << "\n";
            x[ Parallel::pid ] = A[ 1 ][ N ];
            logFile << "111 x[" << Parallel::pid << "] = " << x[ Parallel::pid ] << "\n";
            for ( int k = 0; k < Parallel::nprocs; ++ k )
            {
                if ( k != Parallel::pid )
                {
                    x[ Parallel::pid ] -= A[ 1 ][ 2 * k + 1 ] * x[ k ];
                }
            }
            logFile << "222 x[" << Parallel::pid << "] = " << x[ Parallel::pid ] << "\n";
            logFile << "Parallel::pid = "<< Parallel::pid << "; 2 * Parallel::pid + 1 = " << 2 * Parallel::pid + 1 << "\n";
            logFile << "A[ 1 ][" << 2 * Parallel::pid + 1 << "] = "<< A[ 1 ][ 2 * Parallel::pid + 1 ] << "\n";
            
            x[ Parallel::pid ] = x[ Parallel::pid ] / A[ 1 ][ 2 * Parallel::pid + 1 ];
            logFile << "333 x[" << Parallel::pid << "] = " << x[ Parallel::pid ] << "\n";
        }
    }
    Print( x, "vector x 222" );
}
```

## p=3,nProc=3,N=7
```
p=3,nProc=3,N=7

-2  1  0  0  0  0  0
 1 -2  1  0  0  0  0
 0  1 -2  1  0  0  0
 0  0  1 -2  1  0  0
 0  0  0  1 -2  1  0
 0  0  0  0  1 -2  1
 0  0  0  0  0  1 -2

iProc=0
global_locs = 0 1 2
-2  1  0  0  0  0  0
 1 -2  1  0  0  0  0
 0  1 -2  1  0  0  0

iProc=1
global_locs = 2 3 4
 0  1 -2  1  0  0  0
 0  0  1 -2  1  0  0
 0  0  0  1 -2  1  0

iProc=2
global_locs = 4 5 6
 0  0  0  1 -2  1  0
 0  0  0  0  1 -2  1
 0  0  0  0  0  1 -2
```

detail
```
stage 0
+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1   3   5   +
+    |2   4   6   +
+++++++++++++++++++

stage 1
+----|------------+
+pid |0   1   2   +
+----|------------+
+row |0   2   4   +
+    |1*  3*  5*  +
+    |2   4   6   +
+++++++++++++++++++

stage 0
+----|-------------
+pid | row
+----|-------------
+ 0  |  0
+ 0  |  1
+ 0  |  2
-------------------
+ 1  |  2
+ 1  |  3
+ 1  |  4
-------------------
+ 2  |  4
+ 2  |  5
+ 2  |  6
-------------------

stage 1
+----|-------------
+pid | row
+----|-------------
+ 0  |  0
+ 0  |  1*
+ 0  |  2
-------------------
+ 1  |  2
+ 1  |  3*
+ 1  |  4
-------------------
+ 2  |  4
+ 2  |  5*
+ 2  |  6
-------------------

matrix A 0 =
-2.00  1.00  0.00  0.00  0.00  0.00  0.00 x[0]
 1.00 -2.00  1.00  0.00  0.00  0.00  0.00 x[1]
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00 x[2]
 0.00  0.00  1.00 -2.00  1.00  0.00  0.00 x[3]
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00 x[4]
 0.00  0.00  0.00  0.00  1.00 -2.00  1.00 x[5]
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00 x[6]
 
matrix A after cyclic reduction =
-2.00  1.00  0.00  0.00  0.00  0.00  0.00 x[0]
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00 x[1]
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00 x[2]
 0.00  0.00  0.00 -0.50  0.00  0.00  0.00 x[3]
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00 x[4]
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 x[5]
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00 x[6]
 
pid 0
Matrix A 1 = 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 1.00 -2.00  1.00  0.00  0.00  0.00  0.00  1.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 
Matrix A 2 = 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00  0.00 
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00  2.00 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00  
 
-2.00  1.00  0.00  0.00  0.00  0.00  0.00 x[0]
 0.00 -1.00  0.00  0.50  0.00  0.00  0.00 x[1]
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00 x[2] 
 
pid 1 
Matrix A 1 = 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  1.00 -2.00  1.00  0.00  0.00  3.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
Matrix A 2 = 
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00  2.00 
 0.00  0.00  0.00 -0.50  0.00  0.00  0.00 12.00 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00  
 
pid 2
Matrix A 1 = 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.00  1.00 -2.00  1.00  5.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 

Matrix A 2 = 
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00  4.00 
 0.00  0.00  0.00  0.50  0.00 -1.00  0.00 10.00 
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00  6.00 
```

output
```
p =   0, N =     0, nprocs =    -1
p =   1, N =     1, nprocs =     0
p =   2, N =     3, nprocs =     1
p =   3, N =     7, nprocs =     3
p =   4, N =    15, nprocs =     7
p =   5, N =    31, nprocs =    15
p =   6, N =    63, nprocs =    31
p =   7, N =   127, nprocs =    63
p =   8, N =   255, nprocs =   127
p =   9, N =   511, nprocs =   255
p =  10, N =  1023, nprocs =   511
```

## Cyclic reduction level = 0
```
+pid | row
+----|-------------
+ 0  |  0
+ 0  |  1
+ 0  |  2
-------------------
+ 1  |  2
+ 1  |  3
+ 1  |  4
-------------------
+ 2  |  4
+ 2  |  5
+ 2  |  6
-------------------
Cyclic reduction level = 0
j  = 1 3 5
in = 0 2 4
ip = 2 4 6

//j=1,3,5
iProc = 0,1,2
std::vector<int> jlist;
jlist.push_back(1);
jlist.push_back(3);
jlist.push_back(5);
std::vector<int> jlocal;
jlocals.push_back(1);
jlocals.push_back(1);
jlocals.push_back(1);

for ( int j = jstart; j < N; j = j + jstep )
{
    int in = j - joffset;
    int ip = j + joffset;
    double alpha = A[ j ][ in ] / A[ in ][ in ];
    double gamma = A[ j ][ ip ] / A[ ip ][ ip ];

    for ( int k = 0; k < N; ++ k )
    {
        A[ j ][ k ] -= ( alpha * A[ in ][ k ] + gamma * A[ ip ][ k ] );
    }
}

for ( int iProc = 0; iProc < nProc; ++ iProc )
{
    std::vector<std::vector<double>> &AProc = AProcs[iProc];
	int j = jlist[iProc];
	int jl = jlocals[iProc];
	
    int inl = jlocal - joffset;
    int ipl = jlocal + joffset;
    int in = j - joffset;
    int ip = j + joffset;
    double alpha = AProc[ jl ][ in ] / A[ inl ][ in ];
    double gamma = AProc[ jl ][ ip ] / A[ ipl ][ ip ];	
    for ( int k = 0; k < N; ++ k )
    {
        AProc[ jl ][ k ] -= ( alpha * AProc[ inl ][ k ] + gamma * AProc[ ipl ][ k ] );
    }
}

iProc = 0 Matrix AProc 000  =
-2.00  1.00  0.00  0.00  0.00  0.00  0.00
 1.00 -2.00  1.00  0.00  0.00  0.00  0.00
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00

iProc = 1 Matrix AProc 000  =
 0.00  1.00 -2.00  1.00  0.00  0.00  0.00
 0.00  0.00  1.00 -2.00  1.00  0.00  0.00
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00

iProc = 2 Matrix AProc 000  =
 0.00  0.00  0.00  1.00 -2.00  1.00  0.00
 0.00  0.00  0.00  0.00  1.00 -2.00  1.00
 0.00  0.00  0.00  0.00  0.00  1.00 -2.00
 
```